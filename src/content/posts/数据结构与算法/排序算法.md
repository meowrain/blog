---
title: 排序算法
published: 2025-09-21
description: ''
image: ''
tags: []
category: '数据结构与算法'
draft: false 
lang: ''
---


# 冒泡排序
![](https://blog.meowrain.cn/api/i/2025/09/21/12fnqrb-1.webp)

算法复杂度： O(n^2)
稳定性： 是稳定排序算法，相等的元素不会变换位置

```go
package main
import "fmt"
func main() {
    var n int
    fmt.Scan(&n)
    arr := make([]int,n)
    for i:= range arr {
        fmt.Scan(&arr[i])
    }
    bubbleSort(arr)
    for i,v := range arr {
        if i > 0 {
            fmt.Print(" ")
        }
        fmt.Print(v)
    }
    
}
func bubbleSort(arr []int) {
    n := len(arr)
    for i:=0;i<n-1;i++ {
        for j:=0;j<n-1-i;j++ {
            if arr[j] > arr[j + 1] {
                arr[j],arr[j + 1] = arr[j + 1],arr[j]
            }
        }
    }
}
```
```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i = 0;i<n;i++) {
            arr[i] = sc.nextInt();
        }
        bubbleSort(arr);
        for(int i = 0;i<n;i++) {
            System.out.print(arr[i] + " ");
        }
        
    }
    static void bubbleSort(int[] arr) {
        int n = arr.length;
        for(int i = 0;i<n - 1;i++) {
            for(int j = 0;j<n - 1 - i;j++) {
                int temp = arr[j];
                if(arr[j + 1] < arr[j]) {
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
```



# 快速排序
## 时间复杂度
平均时间复杂度： O(nlogn)
最坏时间复杂度： O(n^2) 在已经排序或者大部分已排序的情况下
最好时间复杂度： O(nlogn)
## 空间复杂度
是原地排序，只占用少量的额外空间，空间复杂度是O(logn)，主要是递归调用栈的空间
## 稳定性
快速排序是 不稳定 排序。

采用分治策略排列元素，把数组分成两个子数组，递归排序，再合并。

分区的基本思想
分区的目标：选择一个基准元素（pivot），将数组重新排列，使得：
## 分区思想
基准左边的所有元素 <= 基准
基准右边的所有元素 >= 基准
基准本身位于最终的正确位置

```go
package main

import "fmt"
func main() {
    var n int
    fmt.Scan(&n)
    arr := make([]int,n)
    for i:= range arr {
        fmt.Scan(&arr[i])
    }
    quickSort(arr,0,len(arr) - 1)
}
func quickSort(arr []int,low int,high int) {
    if low < high {
        pi := partition(arr,low,high)
        quickSort(arr,low,pi - 1)
        quickSort(arr,pi + 1,high)
    }
}
func partition(arr []int,low int,high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low;j < high;j++ {
        if arr[j] <= pivot {
            i++
            arr[i],arr[j] = arr[j],arr[i]
        }
    }
    arr[i + 1],arr[high] = arr[high],arr[i + 1]
    return i + 1
}
```